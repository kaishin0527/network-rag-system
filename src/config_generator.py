



#!/usr/bin/env python3
# config_generator.py
import re
import json
import os
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from datetime import datetime
from knowledge_base import KnowledgeBase, DevicePolicy
from rag_system import NetworkRAGSystem

@dataclass
class GeneratedConfig:
    """生成されたコンフィグ"""
    device_name: str
    config_type: str
    config_content: str
    validation_result: Dict[str, Any]
    metadata: Dict[str, Any]

class NetworkConfigGenerator:
    def __init__(self, kb_dir: str = "/workspace/network-rag-system/knowledge-base"):
        self.kb = KnowledgeBase(kb_dir)
        self.rag_system = NetworkRAGSystem(kb_dir)
        self.generated_configs = []
    
    def generate_config(self, query: str) -> GeneratedConfig:
        """コンフィグの生成"""
        print(f"Generating config for query: {query}")
        
        # RAGシステムでプロンプトを生成
        prompt = self.rag_system.generate_config_prompt(query)
        
        # ここで実際のLLM呼び出しを行う（ダミー実装）
        config_content = self._generate_config_content(prompt)
        
        # 検証
        validation_result = self._validate_config(config_content)
        
        # メタデータの生成
        metadata = self._generate_metadata(query, config_content)
        
        # 生成されたコンフィグの保存
        generated_config = GeneratedConfig(
            device_name=metadata.get('device_name', 'unknown'),
            config_type=metadata.get('config_type', 'unknown'),
            config_content=config_content,
            validation_result=validation_result,
            metadata=metadata
        )
        
        self.generated_configs.append(generated_config)
        
        return generated_config
    
    def _generate_config_content(self, prompt: str) -> str:
        """コンフィグコンテンツの生成（ダミー実装）"""
        # 実際にはLLMを呼び出してコンフィグを生成
        # ここではダミーのコンフィグを返す
        
        # プロンプトからデバイス名を抽出
        device_name = self._extract_device_name_from_prompt(prompt)
        
        # テンプレートの取得
        template = self.kb.get_template("router-template")
        if not template:
            template = self._get_default_template()
        
        # テンプレートの変数置換
        config_content = self._substitute_template_variables(template, device_name, prompt)
        
        return config_content
    
    def _extract_device_name_from_prompt(self, prompt: str) -> str:
        """プロンプトからデバイス名を抽出"""
        device_pattern = r'(?:R1|R2|SW1)'
        match = re.search(device_pattern, prompt)
        return match.group(0) if match else "R1"
    
    def _get_default_template(self) -> str:
        """デフォルトテンプレートの取得"""
        return """
! Default Router Configuration
! Generated by Network Config Generator

hostname {{hostname}}
ip routing

! Interface Configuration
interface Loopback0
 ip address 10.1.1.1 255.255.255.255
!
interface GigabitEthernet0/0
 ip address 192.168.100.1 255.255.255.252
 no shutdown

! OSPF Configuration
router ospf 1
 router-id 10.1.1.1
 network 10.1.0.0 0.0.255.255 area 0
 network 192.168.100.0 0.0.0.3 area 0
 passive-interface default
 no passive-interface GigabitEthernet0/0

! Security Configuration
snmp-server community public_ro RO
snmp-server community private_rw RW

! Monitoring Configuration
logging host 192.168.100.100
ntp server 192.168.100.100
"""
    
    def _substitute_template_variables(self, template: str, device_name: str, prompt: str) -> str:
        """テンプレート変数の置換"""
        # デバイスポリシーの取得
        policy = self.kb.get_device_policy(device_name)
        
        # 変数の置換
        config = template.replace('{{hostname}}', device_name)
        
        if policy:
            config = config.replace('{{router_id}}', policy.ospf_config.get('router_id', '10.1.1.1'))
            config = config.replace('{{basic_settings}}', self._generate_basic_settings(policy))
            config = config.replace('{{interfaces}}', self._generate_interfaces(policy))
            config = config.replace('{{ospf_networks}}', self._generate_ospf_networks(policy))
            config = config.replace('{{security_settings}}', self._generate_security_settings(policy))
            config = config.replace('{{ha_settings}}', self._generate_ha_settings(policy))
            config = config.replace('{{monitoring_settings}}', self._generate_monitoring_settings(policy))
        
        # 要件の置換
        requirements = self._extract_requirements_from_prompt(prompt)
        config = config.replace('{{requirements}}', requirements)
        
        return config
    
    def _generate_basic_settings(self, policy: DevicePolicy) -> str:
        """基本設定の生成"""
        settings = []
        
        # 基本設定の追加
        settings.append("service timestamps debug datetime msec")
        settings.append("service timestamps log datetime msec")
        settings.append("no ip domain-lookup")
        settings.append("ip domain-name company.local")
        
        return "\n".join(settings)
    
    def _generate_interfaces(self, policy: DevicePolicy) -> str:
        """インターフェース設定の生成"""
        interface_configs = []
        
        for interface in policy.interfaces:
            interface_configs.append(f"! {interface}")
        
        return "\n".join(interface_configs)
    
    def _generate_ospf_networks(self, policy: DevicePolicy) -> str:
        """OSPFネットワーク設定の生成"""
        networks = []
        
        if 'areas' in policy.ospf_config:
            for area, network in policy.ospf_config['areas'].items():
                networks.append(f" network {network} area {area}")
        
        return "\n".join(networks)
    
    def _generate_security_settings(self, policy: DevicePolicy) -> str:
        """セキュリティ設定の生成"""
        settings = []
        
        if 'snmp_community' in policy.security_config:
            for community in policy.security_config['snmp_community']:
                settings.append(f"snmp-server community \"{community}\" RO")
        
        return "\n".join(settings)
    
    def _generate_ha_settings(self, policy: DevicePolicy) -> str:
        """高可用性設定の生成"""
        settings = []
        
        if 'hsrp_groups' in policy.ha_config:
            for group, ip in policy.ha_config['hsrp_groups'].items():
                settings.append(f"! HSRP Group {group}")
                settings.append(f"standby {group} ip {ip}")
        
        return "\n".join(settings)
    
    def _generate_monitoring_settings(self, policy: DevicePolicy) -> str:
        """監視設定の生成"""
        settings = []
        
        if 'syslog_server' in policy.monitoring_config:
            settings.append(f"logging host {policy.monitoring_config['syslog_server']}")
        
        if 'ntp_server' in policy.monitoring_config:
            settings.append(f"ntp server {policy.monitoring_config['ntp_server']}")
        
        return "\n".join(settings)
    
    def _extract_requirements_from_prompt(self, prompt: str) -> str:
        """プロンプトから要件を抽出"""
        # プロンプトから要件部分を抽出
        requirement_pattern = r'## 追加要件\s*\n*(.*?)(?:\n##|\Z)'
        match = re.search(requirement_pattern, prompt, re.DOTALL)
        
        if match:
            return match.group(1).strip()
        
        return "No specific requirements"
    
    def _validate_config(self, config_content: str) -> Dict[str, Any]:
        """コンフィグの検証"""
        validation_result = {
            'is_valid': True,
            'errors': [],
            'warnings': [],
            'validation_rules': {}
        }
        
        # 基本的な構文チェック
        if not self._validate_syntax(config_content):
            validation_result['is_valid'] = False
            validation_result['errors'].append("Invalid configuration syntax")
        
        # IPアドレスの検証
        ip_validation = self._validate_ip_addresses(config_content)
        validation_result['validation_rules']['ip_validation'] = ip_validation
        
        if not ip_validation['is_valid']:
            validation_result['is_valid'] = False
            validation_result['errors'].extend(ip_validation['errors'])
        
        # OSPF設定の検証
        ospf_validation = self._validate_ospf_config(config_content)
        validation_result['validation_rules']['ospf_validation'] = ospf_validation
        
        if not ospf_validation['is_valid']:
            validation_result['warnings'].extend(ospf_validation['warnings'])
        
        return validation_result
    
    def _validate_syntax(self, config_content: str) -> bool:
        """構文の検証"""
        # 簡易的な構文チェック
        lines = config_content.split('\n')
        
        for line in lines:
            line = line.strip()
            if line and not line.startswith('!') and not line.startswith('interface'):
                # 基本的なコマンド形式のチェック
                if not re.match(r'^\w+(\s+\S+)*$', line):
                    return False
        
        return True
    
    def _validate_ip_addresses(self, config_content: str) -> Dict[str, Any]:
        """IPアドレスの検証"""
        validation = {
            'is_valid': True,
            'errors': [],
            'warnings': [],
            'ip_addresses': []
        }
        
        # IPアドレスの抽出
        ip_pattern = r'ip address (\d+\.\d+\.\d+\.\d+/\d+)'
        ip_matches = re.findall(ip_pattern, config_content)
        
        for ip in ip_matches:
            validation['ip_addresses'].append(ip)
            
            # プライベートIPアドレスのチェック
            if not self._is_private_ip(ip):
                validation['warnings'].append(f"Public IP address detected: {ip}")
        
        return validation
    
    def _validate_ospf_config(self, config_content: str) -> Dict[str, Any]:
        """OSPF設定の検証"""
        validation = {
            'is_valid': True,
            'errors': [],
            'warnings': [],
            'areas': []
        }
        
        # OSPFエリアの抽出
        ospf_pattern = r'network (\d+\.\d+\.\d+\.\d+/\d+) area (\d+)'
        ospf_matches = re.findall(ospf_pattern, config_content)
        
        for network, area in ospf_matches:
            validation['areas'].append({'network': network, 'area': area})
            
            # Area 0のチェック
            if area == '0':
                validation['warnings'].append(f"Network {network} is in Area 0 (backbone)")
        
        return validation
    
    def _is_private_ip(self, ip_with_mask: str) -> bool:
        """プライベートIPアドレスの判定"""
        # マスクを除去
        ip = ip_with_mask.split('/')[0]
        octets = ip.split('.')
        
        # プライベートIPアドレス範囲のチェック
        private_ranges = [
            (10, 0, 0, 0, 10, 255, 255, 255),      # 10.0.0.0/8
            (172, 16, 0, 0, 172, 31, 255, 255),    # 172.16.0.0/12
            (192, 168, 0, 0, 192, 168, 255, 255),  # 192.168.0.0/16
        ]
        
        for first, second_min, third_min, fourth_min, first_max, second_max, third_max, fourth_max in private_ranges:
            if (first <= int(octets[0]) <= first_max and
                second_min <= int(octets[1]) <= second_max and
                third_min <= int(octets[2]) <= third_max and
                fourth_min <= int(octets[3]) <= fourth_max):
                return True
        
        return False
    
    def _generate_metadata(self, query: str, config_content: str) -> Dict[str, Any]:
        """メタデータの生成"""
        metadata = {
            'query': query,
            'timestamp': str(datetime.now()),
            'config_length': len(config_content),
            'line_count': len(config_content.split('\n')),
            'device_name': self._extract_device_name_from_prompt(query),
            'config_type': self._extract_config_type_from_query(query),
            'validation_rules_applied': ['ip_validation', 'ospf_validation'],
            'template_used': 'router-template'
        }
        
        return metadata
    
    def _extract_config_type_from_query(self, query: str) -> str:
        """クエリから設定タイプを抽出"""
        config_patterns = {
            'ospf': r'ospf|ルーティング',
            'interface': r'interface|インターフェース',
            'security': r'security|セキュリティ|acl',
            'ha': r'ha|高可用性|hsrp',
            'monitoring': r'monitoring|監視'
        }
        
        for config_type, pattern in config_patterns.items():
            if re.search(pattern, query, re.IGNORECASE):
                return config_type
        
        return 'general'
    
    def get_generated_configs(self) -> List[GeneratedConfig]:
        """生成されたコンフィグの取得"""
        return self.generated_configs
    
    def save_config(self, config: GeneratedConfig, output_dir: str = "/tmp/generated_configs") -> tuple:
        """コンフィグの保存"""
        os.makedirs(output_dir, exist_ok=True)
        
        # ファイル名の生成
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{config.device_name}_{config.config_type}_{timestamp}.txt"
        filepath = os.path.join(output_dir, filename)
        
        # ファイルへの書き込み
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(f"! Generated Config for {config.device_name}\n")
            f.write(f"! Config Type: {config.config_type}\n")
            f.write(f"! Generated: {config.metadata['timestamp']}\n")
            f.write(f"! Validation: {'PASS' if config.validation_result['is_valid'] else 'FAIL'}\n")
            f.write("\n")
            f.write(config.config_content)
        
        # 検証結果の保存
        validation_filename = f"{config.device_name}_{config.config_type}_{timestamp}_validation.json"
        validation_filepath = os.path.join(output_dir, validation_filename)
        
        with open(validation_filepath, 'w', encoding='utf-8') as f:
            json.dump({
                'device_name': config.device_name,
                'config_type': config.config_type,
                'validation_result': config.validation_result,
                'metadata': config.metadata
            }, f, indent=2, ensure_ascii=False)
        
        return filepath, validation_filepath



